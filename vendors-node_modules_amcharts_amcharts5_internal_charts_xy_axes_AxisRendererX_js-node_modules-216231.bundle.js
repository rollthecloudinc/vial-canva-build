"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcbdc_carbon_reporting_dashboard"] = self["webpackChunkcbdc_carbon_reporting_dashboard"] || []).push([["vendors-node_modules_amcharts_amcharts5_internal_charts_xy_axes_AxisRendererX_js-node_modules-216231"],{

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisRendererX: () => (/* binding */ AxisRendererX)\n/* harmony export */ });\n/* harmony import */ var _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxisRenderer */ \"./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js\");\n/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js\");\n/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Type */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js\");\n/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Utils */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js\");\n/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Rectangle */ \"./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Used to render horizontal axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info\r\n * @important\r\n */\r\nclass AxisRendererX extends _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer {\r\n    constructor() {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"thumb\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, isMeasured: false, themeTags: [\"axis\", \"x\", \"thumb\"] })\r\n        });\r\n    }\r\n    _afterNew() {\r\n        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.mergeTags(this._settings.themeTags, [\"renderer\", \"x\"]);\r\n        super._afterNew();\r\n        this.setPrivateRaw(\"letter\", \"X\");\r\n        const gridTemplate = this.grid.template;\r\n        gridTemplate.set(\"height\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n        gridTemplate.set(\"width\", 0);\r\n        gridTemplate.set(\"draw\", (display, graphics) => {\r\n            display.moveTo(0, 0);\r\n            display.lineTo(0, graphics.height());\r\n        });\r\n        this.set(\"draw\", (display, graphics) => {\r\n            display.moveTo(0, 0);\r\n            display.lineTo(graphics.width(), 0);\r\n        });\r\n    }\r\n    _changed() {\r\n        super._changed();\r\n        const axis = this.axis;\r\n        axis.ghostLabel.setPrivate(\"visible\", !this.get(\"inside\"));\r\n        axis.ghostLabel.set(\"x\", -1000);\r\n        const opposite = \"opposite\";\r\n        const inside = \"inside\";\r\n        if (this.isDirty(opposite) || this.isDirty(inside)) {\r\n            const chart = this.chart;\r\n            const axisChildren = axis.children;\r\n            if (this.get(inside)) {\r\n                axis.addTag(inside);\r\n            }\r\n            else {\r\n                axis.removeTag(inside);\r\n            }\r\n            if (chart) {\r\n                if (this.get(opposite)) {\r\n                    const children = chart.topAxesContainer.children;\r\n                    if (children.indexOf(axis) == -1) {\r\n                        children.insertIndex(0, axis);\r\n                    }\r\n                    axis.addTag(opposite);\r\n                    axisChildren.moveValue(this);\r\n                }\r\n                else {\r\n                    const children = chart.bottomAxesContainer.children;\r\n                    if (children.indexOf(axis) == -1) {\r\n                        children.moveValue(axis);\r\n                    }\r\n                    axis.removeTag(opposite);\r\n                    axisChildren.moveValue(this, 0);\r\n                }\r\n                axis.ghostLabel._applyThemes();\r\n                this.labels.each((label) => {\r\n                    label._applyThemes();\r\n                });\r\n                this.root._markDirtyRedraw();\r\n            }\r\n            axis.markDirtySize();\r\n        }\r\n        this.thumb.setPrivate(\"height\", axis.labelsContainer.height());\r\n    }\r\n    _getPan(point1, point2) {\r\n        return (point2.x - point1.x) / this.width();\r\n    }\r\n    toAxisPosition(position) {\r\n        const start = this._start || 0;\r\n        const end = this._end || 1;\r\n        position -= this._ls;\r\n        position = position * (end - start) / this._lc;\r\n        if (!this.get(\"inversed\")) {\r\n            position = start + position;\r\n        }\r\n        else {\r\n            position = end - position;\r\n        }\r\n        return position;\r\n    }\r\n    _updateLC() {\r\n        const axis = this.axis;\r\n        const parent = axis.parent;\r\n        if (parent) {\r\n            const w = parent.innerWidth();\r\n            this._lc = this.axisLength() / w;\r\n            this._ls = (axis.x() - parent.get(\"paddingLeft\", 0)) / w;\r\n        }\r\n    }\r\n    _updatePositions() {\r\n        const axis = this.axis;\r\n        const x = axis.x() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(axis.get(\"centerX\", 0), axis.width()) - axis.parent.get(\"paddingLeft\", 0);\r\n        axis.gridContainer.set(\"x\", x);\r\n        axis.topGridContainer.set(\"x\", x);\r\n        axis.bulletsContainer.set(\"y\", this.y());\r\n        const chart = axis.chart;\r\n        if (chart) {\r\n            const plotContainer = chart.plotContainer;\r\n            const axisHeader = axis.axisHeader;\r\n            let width = axis.get(\"marginLeft\", 0);\r\n            let x = axis.x() - width;\r\n            const parent = axis.parent;\r\n            if (parent) {\r\n                x -= parent.get(\"paddingLeft\", 0);\r\n            }\r\n            if (axisHeader.children.length > 0) {\r\n                width = axis.axisHeader.width();\r\n                axis.set(\"marginLeft\", width + 1);\r\n            }\r\n            else {\r\n                axisHeader.set(\"width\", width);\r\n            }\r\n            axisHeader.setAll({ x: x, y: -1, height: plotContainer.height() + 2 });\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    processAxis() {\r\n        super.processAxis();\r\n        const axis = this.axis;\r\n        axis.set(\"width\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n        const verticalLayout = this._root.verticalLayout;\r\n        axis.set(\"layout\", verticalLayout);\r\n        axis.labelsContainer.set(\"width\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n        axis.axisHeader.setAll({ layout: verticalLayout });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    axisLength() {\r\n        return this.axis.width();\r\n    }\r\n    /**\r\n     * Converts axis relative position to actual coordinate in pixels.\r\n     *\r\n     * @param   position  Position\r\n     * @return            Point\r\n     */\r\n    positionToPoint(position) {\r\n        return { x: this.positionToCoordinate(position), y: 0 };\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateTick(tick, position, endPosition, count) {\r\n        if (tick) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            let location = 0.5;\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {\r\n                location = tick.get(\"multiLocation\", location);\r\n            }\r\n            else {\r\n                location = tick.get(\"location\", location);\r\n            }\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                position = position + (endPosition - position) * location;\r\n            }\r\n            tick.set(\"x\", this.positionToCoordinate(position));\r\n            let length = tick.get(\"length\", 0);\r\n            const inside = tick.get(\"inside\", this.get(\"inside\", false));\r\n            if (this.get(\"opposite\")) {\r\n                tick.set(\"y\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n                if (!inside) {\r\n                    length *= -1;\r\n                }\r\n            }\r\n            else {\r\n                tick.set(\"y\", 0);\r\n                if (inside) {\r\n                    length *= -1;\r\n                }\r\n            }\r\n            tick.set(\"draw\", (display) => {\r\n                display.moveTo(0, 0);\r\n                display.lineTo(0, length);\r\n            });\r\n            this.toggleVisibility(tick, position, tick.get(\"minPosition\", 0), tick.get(\"maxPosition\", 1));\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateLabel(label, position, endPosition, count) {\r\n        if (label) {\r\n            let location = 0.5;\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {\r\n                location = label.get(\"multiLocation\", location);\r\n            }\r\n            else {\r\n                location = label.get(\"location\", location);\r\n            }\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            const inside = label.get(\"inside\", this.get(\"inside\", false));\r\n            const opposite = this.get(\"opposite\");\r\n            if (opposite) {\r\n                if (!inside) {\r\n                    label.set(\"position\", \"relative\");\r\n                    label.set(\"y\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n                }\r\n                else {\r\n                    label.set(\"position\", \"absolute\");\r\n                    label.set(\"y\", 0);\r\n                }\r\n            }\r\n            else {\r\n                if (!inside) {\r\n                    label.set(\"y\", undefined);\r\n                    label.set(\"position\", \"relative\");\r\n                }\r\n                else {\r\n                    label.set(\"y\", 0);\r\n                    label.set(\"position\", \"absolute\");\r\n                }\r\n            }\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                position = position + (endPosition - position) * location;\r\n            }\r\n            label.set(\"x\", this.positionToCoordinate(position));\r\n            this.toggleVisibility(label, position, label.get(\"minPosition\", 0), label.get(\"maxPosition\", 1));\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateGrid(grid, position, endPosition) {\r\n        if (grid) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            let location = grid.get(\"location\", 0.5);\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                position = position + (endPosition - position) * location;\r\n            }\r\n            grid.set(\"x\", this.positionToCoordinate(position));\r\n            this.toggleVisibility(grid, position, 0, 1);\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateBullet(bullet, position, endPosition) {\r\n        if (bullet) {\r\n            const sprite = bullet.get(\"sprite\");\r\n            if (sprite) {\r\n                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                    position = 0;\r\n                }\r\n                let location = bullet.get(\"location\", 0.5);\r\n                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                    position = position + (endPosition - position) * location;\r\n                }\r\n                let bulletPosition = this.axis.roundAxisPosition(position, location);\r\n                let previousBullet = this.axis._bullets[bulletPosition];\r\n                let d = -1;\r\n                if (this.get(\"opposite\")) {\r\n                    d = 1;\r\n                }\r\n                if (bullet.get(\"stacked\")) {\r\n                    if (previousBullet) {\r\n                        let previousSprite = previousBullet.get(\"sprite\");\r\n                        if (previousSprite) {\r\n                            sprite.set(\"y\", previousSprite.y() + previousSprite.height() * d);\r\n                        }\r\n                    }\r\n                    else {\r\n                        sprite.set(\"y\", 0);\r\n                    }\r\n                }\r\n                this.axis._bullets[bulletPosition] = bullet;\r\n                sprite.set(\"x\", this.positionToCoordinate(position));\r\n                this.toggleVisibility(sprite, position, 0, 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateFill(fill, position, endPosition) {\r\n        if (fill) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition)) {\r\n                endPosition = 1;\r\n            }\r\n            let x0 = this.positionToCoordinate(position);\r\n            let x1 = this.positionToCoordinate(endPosition);\r\n            this.fillDrawMethod(fill, x0, x1);\r\n        }\r\n    }\r\n    fillDrawMethod(fill, x0, x1) {\r\n        fill.set(\"draw\", (display) => {\r\n            //display.drawRect(x0, 0, x1 - x0, this.axis!.gridContainer.height());\r\n            // using for holes, so can not be rectangle\r\n            const h = this.axis.gridContainer.height();\r\n            const w = this.width();\r\n            if (x1 < x0) {\r\n                [x1, x0] = [x0, x1];\r\n            }\r\n            if (x0 > w || x1 < 0) {\r\n                return;\r\n            }\r\n            /*\r\n            const limit = 10000;\r\n\r\n            x0 = Math.max(-limit, x0);\r\n            x1 = Math.min(limit, x1);\r\n            */\r\n            display.moveTo(x0, 0);\r\n            display.lineTo(x1, 0);\r\n            display.lineTo(x1, h);\r\n            display.lineTo(x0, h);\r\n            display.lineTo(x0, 0);\r\n        });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    positionTooltip(tooltip, position) {\r\n        this._positionTooltip(tooltip, { x: this.positionToCoordinate(position), y: 0 });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateTooltipBounds(tooltip) {\r\n        const inside = this.get(\"inside\");\r\n        const num = 100000;\r\n        let global = this._display.toGlobal({ x: 0, y: 0 });\r\n        let x = global.x;\r\n        let y = 0;\r\n        let w = this.axisLength();\r\n        let h = num;\r\n        let pointerOrientation = \"up\";\r\n        if (this.get(\"opposite\")) {\r\n            if (inside) {\r\n                pointerOrientation = \"up\";\r\n                y = global.y;\r\n                h = num;\r\n            }\r\n            else {\r\n                pointerOrientation = \"down\";\r\n                y = global.y - num;\r\n                h = num;\r\n            }\r\n        }\r\n        else {\r\n            if (inside) {\r\n                pointerOrientation = \"down\";\r\n                y = global.y - num;\r\n                h = num;\r\n            }\r\n            else {\r\n                pointerOrientation = \"up\";\r\n                y = global.y;\r\n                h = num;\r\n            }\r\n        }\r\n        const bounds = { left: x, right: x + w, top: y, bottom: y + h };\r\n        const oldBounds = tooltip.get(\"bounds\");\r\n        if (!_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.sameBounds(bounds, oldBounds)) {\r\n            tooltip.set(\"bounds\", bounds);\r\n            tooltip.set(\"pointerOrientation\", pointerOrientation);\r\n        }\r\n    }\r\n}\r\nObject.defineProperty(AxisRendererX, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"AxisRendererX\"\r\n});\r\nObject.defineProperty(AxisRendererX, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer.classNames.concat([AxisRendererX.className])\r\n});\r\n//# sourceMappingURL=AxisRendererX.js.map\n\n//# sourceURL=webpack://cbdc-carbon-reporting-dashboard/./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js?");

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisRendererY: () => (/* binding */ AxisRendererY)\n/* harmony export */ });\n/* harmony import */ var _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxisRenderer */ \"./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js\");\n/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js\");\n/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Type */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js\");\n/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Utils */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js\");\n/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Rectangle */ \"./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Used to render vertical axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info\r\n * @important\r\n */\r\nclass AxisRendererY extends _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer {\r\n    constructor() {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"_downY\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"thumb\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, isMeasured: false, themeTags: [\"axis\", \"y\", \"thumb\"] })\r\n        });\r\n    }\r\n    _afterNew() {\r\n        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.mergeTags(this._settings.themeTags, [\"renderer\", \"y\"]);\r\n        if (this._settings.opposite) {\r\n            this._settings.themeTags.push(\"opposite\");\r\n        }\r\n        super._afterNew();\r\n        this.setPrivateRaw(\"letter\", \"Y\");\r\n        const gridTemplate = this.grid.template;\r\n        gridTemplate.set(\"width\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n        gridTemplate.set(\"height\", 0);\r\n        gridTemplate.set(\"draw\", (display, graphics) => {\r\n            display.moveTo(0, 0);\r\n            display.lineTo(graphics.width(), 0);\r\n        });\r\n        this.set(\"draw\", (display, renderer) => {\r\n            display.moveTo(0, 0);\r\n            display.lineTo(0, renderer.height());\r\n        });\r\n    }\r\n    _getPan(point1, point2) {\r\n        return (point1.y - point2.y) / this.height();\r\n    }\r\n    _changed() {\r\n        super._changed();\r\n        const axis = this.axis;\r\n        axis.ghostLabel.setPrivate(\"visible\", !this.get(\"inside\"));\r\n        axis.ghostLabel.set(\"y\", -1000);\r\n        const thumb = this.thumb;\r\n        const opposite = \"opposite\";\r\n        const inside = \"inside\";\r\n        const chart = this.chart;\r\n        if (this.isDirty(opposite) || this.isDirty(inside)) {\r\n            const axisChildren = axis.children;\r\n            if (this.get(inside)) {\r\n                axis.addTag(inside);\r\n            }\r\n            else {\r\n                axis.removeTag(inside);\r\n            }\r\n            if (chart) {\r\n                if (this.get(opposite)) {\r\n                    const children = chart.rightAxesContainer.children;\r\n                    if (children.indexOf(axis) == -1) {\r\n                        children.moveValue(axis, 0);\r\n                    }\r\n                    axis.addTag(opposite);\r\n                    axisChildren.moveValue(this, 0);\r\n                }\r\n                else {\r\n                    const children = chart.leftAxesContainer.children;\r\n                    if (children.indexOf(axis) == -1) {\r\n                        children.moveValue(axis);\r\n                    }\r\n                    axis.removeTag(opposite);\r\n                    axisChildren.moveValue(this);\r\n                }\r\n                axis.ghostLabel._applyThemes();\r\n                this.labels.each((label) => {\r\n                    label._applyThemes();\r\n                });\r\n                this.root._markDirtyRedraw();\r\n            }\r\n            axis.markDirtySize();\r\n        }\r\n        const w = axis.labelsContainer.width();\r\n        if (chart) {\r\n            if (this.get(opposite)) {\r\n                thumb.set(\"centerX\", 0);\r\n            }\r\n            else {\r\n                thumb.set(\"centerX\", w);\r\n            }\r\n        }\r\n        thumb.setPrivate(\"width\", w);\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    processAxis() {\r\n        super.processAxis();\r\n        const axis = this.axis;\r\n        if (axis.get(\"height\") == null) {\r\n            axis.set(\"height\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n        }\r\n        const horizontalLayout = this._root.horizontalLayout;\r\n        axis.set(\"layout\", horizontalLayout);\r\n        axis.labelsContainer.set(\"height\", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);\r\n        axis.axisHeader.set(\"layout\", horizontalLayout);\r\n    }\r\n    _updatePositions() {\r\n        const axis = this.axis;\r\n        const y = axis.y() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(axis.get(\"centerY\", 0), axis.height());\r\n        axis.gridContainer.set(\"y\", y);\r\n        axis.topGridContainer.set(\"y\", y);\r\n        axis.bulletsContainer.set(\"x\", this.x());\r\n        const chart = axis.chart;\r\n        if (chart) {\r\n            const plotContainer = chart.plotContainer;\r\n            const axisHeader = axis.axisHeader;\r\n            let height = axis.get(\"marginTop\", 0);\r\n            if (axisHeader.children.length > 0) {\r\n                height = axis.axisHeader.height();\r\n                axis.set(\"marginTop\", height + 1);\r\n            }\r\n            else {\r\n                axisHeader.set(\"height\", height);\r\n            }\r\n            axisHeader.setAll({ y: axis.y() - height, x: -1, width: plotContainer.width() + 2 });\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    axisLength() {\r\n        return this.axis.innerHeight();\r\n    }\r\n    /**\r\n     * Converts axis relative position to actual coordinate in pixels.\r\n     *\r\n     * @param   position  Position\r\n     * @return            Point\r\n     */\r\n    positionToPoint(position) {\r\n        return { x: 0, y: this.positionToCoordinate(position) };\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateLabel(label, position, endPosition, count) {\r\n        if (label) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            let location = 0.5;\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {\r\n                location = label.get(\"multiLocation\", location);\r\n            }\r\n            else {\r\n                location = label.get(\"location\", location);\r\n            }\r\n            const opposite = this.get(\"opposite\");\r\n            const inside = label.get(\"inside\", this.get(\"inside\", false));\r\n            if (opposite) {\r\n                label.set(\"x\", 0);\r\n                if (inside) {\r\n                    label.set(\"position\", \"absolute\");\r\n                }\r\n                else {\r\n                    label.set(\"position\", \"relative\");\r\n                }\r\n            }\r\n            else {\r\n                if (inside) {\r\n                    label.set(\"x\", 0);\r\n                    label.set(\"position\", \"absolute\");\r\n                }\r\n                else {\r\n                    label.set(\"x\", undefined);\r\n                    label.set(\"position\", \"relative\");\r\n                }\r\n            }\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                position = position + (endPosition - position) * location;\r\n            }\r\n            label.set(\"y\", this.positionToCoordinate(position));\r\n            this.toggleVisibility(label, position, label.get(\"minPosition\", 0), label.get(\"maxPosition\", 1));\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateGrid(grid, position, endPosition) {\r\n        if (grid) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            let location = grid.get(\"location\", 0.5);\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                position = position + (endPosition - position) * location;\r\n            }\r\n            grid.set(\"y\", this.positionToCoordinate(position));\r\n            this.toggleVisibility(grid, position, 0, 1);\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateTick(tick, position, endPosition, count) {\r\n        if (tick) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            let location = 0.5;\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {\r\n                location = tick.get(\"multiLocation\", location);\r\n            }\r\n            else {\r\n                location = tick.get(\"location\", location);\r\n            }\r\n            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                position = position + (endPosition - position) * location;\r\n            }\r\n            tick.set(\"y\", this.positionToCoordinate(position));\r\n            let length = tick.get(\"length\", 0);\r\n            const inside = tick.get(\"inside\", this.get(\"inside\", false));\r\n            if (this.get(\"opposite\")) {\r\n                tick.set(\"x\", 0);\r\n                if (inside) {\r\n                    length *= -1;\r\n                }\r\n            }\r\n            else {\r\n                if (!inside) {\r\n                    length *= -1;\r\n                }\r\n            }\r\n            tick.set(\"draw\", (display) => {\r\n                display.moveTo(0, 0);\r\n                display.lineTo(length, 0);\r\n            });\r\n            this.toggleVisibility(tick, position, tick.get(\"minPosition\", 0), tick.get(\"maxPosition\", 1));\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateBullet(bullet, position, endPosition) {\r\n        if (bullet) {\r\n            const sprite = bullet.get(\"sprite\");\r\n            if (sprite) {\r\n                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                    position = 0;\r\n                }\r\n                let location = bullet.get(\"location\", 0.5);\r\n                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {\r\n                    position = position + (endPosition - position) * location;\r\n                }\r\n                let bulletPosition = this.axis.roundAxisPosition(position, location);\r\n                let previousBullet = this.axis._bullets[bulletPosition];\r\n                let d = 1;\r\n                if (this.get(\"opposite\")) {\r\n                    d = -1;\r\n                }\r\n                if (bullet.get(\"stacked\")) {\r\n                    if (previousBullet) {\r\n                        let previousSprite = previousBullet.get(\"sprite\");\r\n                        if (previousSprite) {\r\n                            sprite.set(\"x\", previousSprite.x() + previousSprite.width() * d);\r\n                        }\r\n                    }\r\n                    else {\r\n                        sprite.set(\"x\", 0);\r\n                    }\r\n                }\r\n                this.axis._bullets[bulletPosition] = bullet;\r\n                sprite.set(\"y\", this.positionToCoordinate(position));\r\n                this.toggleVisibility(sprite, position, 0, 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateFill(fill, position, endPosition) {\r\n        if (fill) {\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {\r\n                position = 0;\r\n            }\r\n            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition)) {\r\n                endPosition = 1;\r\n            }\r\n            let y0 = this.positionToCoordinate(position);\r\n            let y1 = this.positionToCoordinate(endPosition);\r\n            this.fillDrawMethod(fill, y0, y1);\r\n        }\r\n    }\r\n    fillDrawMethod(fill, y0, y1) {\r\n        fill.set(\"draw\", (display) => {\r\n            // using for holes, so can not be rectangle\r\n            const w = this.axis.gridContainer.width();\r\n            const h = this.height();\r\n            if (y1 < y0) {\r\n                [y1, y0] = [y0, y1];\r\n            }\r\n            if (y0 > h || y1 < 0) {\r\n                return;\r\n            }\r\n            //y0 = Math.max(0, y0);\r\n            //y1 = Math.min(h, y1);\r\n            display.moveTo(0, y0);\r\n            display.lineTo(w, y0);\r\n            display.lineTo(w, y1);\r\n            display.lineTo(0, y1);\r\n            display.lineTo(0, y0);\r\n        });\r\n    }\r\n    /**\r\n     * Converts relative position (0-1) on axis to a pixel coordinate.\r\n     *\r\n     * @param position  Position (0-1)\r\n     * @return Coordinate (px)\r\n     */\r\n    positionToCoordinate(position) {\r\n        if (!this._inversed) {\r\n            return (this._end - position) * this._axisLength;\r\n        }\r\n        else {\r\n            return (position - this._start) * this._axisLength;\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    positionTooltip(tooltip, position) {\r\n        this._positionTooltip(tooltip, { x: 0, y: this.positionToCoordinate(position) });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    updateTooltipBounds(tooltip) {\r\n        const inside = this.get(\"inside\");\r\n        const num = 100000;\r\n        let global = this._display.toGlobal({ x: 0, y: 0 });\r\n        let y = global.y;\r\n        let x = 0;\r\n        let h = this.axisLength();\r\n        let w = num;\r\n        let pointerOrientation = \"right\";\r\n        if (this.get(\"opposite\")) {\r\n            if (inside) {\r\n                pointerOrientation = \"right\";\r\n                x = global.x - num;\r\n                w = num;\r\n            }\r\n            else {\r\n                pointerOrientation = \"left\";\r\n                x = global.x;\r\n                w = num;\r\n            }\r\n        }\r\n        else {\r\n            if (inside) {\r\n                pointerOrientation = \"left\";\r\n                x = global.x;\r\n                w = num;\r\n            }\r\n            else {\r\n                pointerOrientation = \"right\";\r\n                x = global.x - num;\r\n                w = num;\r\n            }\r\n        }\r\n        const bounds = { left: x, right: x + w, top: y, bottom: y + h };\r\n        const oldBounds = tooltip.get(\"bounds\");\r\n        if (!_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.sameBounds(bounds, oldBounds)) {\r\n            tooltip.set(\"bounds\", bounds);\r\n            tooltip.set(\"pointerOrientation\", pointerOrientation);\r\n        }\r\n    }\r\n    _updateLC() {\r\n        const axis = this.axis;\r\n        const parent = axis.parent;\r\n        if (parent) {\r\n            const h = parent.innerHeight();\r\n            this._lc = this.axisLength() / h;\r\n            this._ls = axis.y() / h;\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    toAxisPosition(position) {\r\n        const start = this._start || 0;\r\n        const end = this._end || 1;\r\n        position -= this._ls;\r\n        position = position * (end - start) / this._lc;\r\n        if (this.get(\"inversed\")) {\r\n            position = start + position;\r\n        }\r\n        else {\r\n            position = end - position;\r\n        }\r\n        return position;\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    fixPosition(position) {\r\n        if (!this.get(\"inversed\")) {\r\n            return 1 - position;\r\n        }\r\n        return position;\r\n    }\r\n}\r\nObject.defineProperty(AxisRendererY, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"AxisRendererY\"\r\n});\r\nObject.defineProperty(AxisRendererY, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer.classNames.concat([AxisRendererY.className])\r\n});\r\n//# sourceMappingURL=AxisRendererY.js.map\n\n//# sourceURL=webpack://cbdc-carbon-reporting-dashboard/./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js?");

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/GaplessDateAxis.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/GaplessDateAxis.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GaplessDateAxis: () => (/* binding */ GaplessDateAxis)\n/* harmony export */ });\n/* harmony import */ var _DateAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DateAxis */ \"./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DateAxis.js\");\n/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/render/Component */ \"./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js\");\n/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Array */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js\");\n/* harmony import */ var _core_util_Order__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Order */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js\");\n/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Time */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js\");\n/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Type */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js\");\n/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Math */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A version of a [[DateAxis]] which removes intervals that don't have any data\r\n * items in them.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info\r\n * @important\r\n */\r\nclass GaplessDateAxis extends _DateAxis__WEBPACK_IMPORTED_MODULE_0__.DateAxis {\r\n    constructor() {\r\n        super(...arguments);\r\n        Object.defineProperty(this, \"_frequency\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: 1\r\n        });\r\n        Object.defineProperty(this, \"_dates\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: []\r\n        });\r\n    }\r\n    _afterNew() {\r\n        this.valueFields.push(\"date\");\r\n        super._afterNew();\r\n    }\r\n    _updateDates(date) {\r\n        const dates = this._dates;\r\n        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.getSortedIndex(dates, (x) => _core_util_Order__WEBPACK_IMPORTED_MODULE_2__.compare(x, date));\r\n        if (!result.found) {\r\n            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.insertIndex(dates, result.index, date);\r\n        }\r\n    }\r\n    _updateAllDates() {\r\n        this._dates.length = 0;\r\n        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(this.series, (series) => {\r\n            let field = \"valueX\";\r\n            if (series.get(\"yAxis\") == this) {\r\n                field = \"valueY\";\r\n            }\r\n            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(series.dataItems, (dataItem) => {\r\n                let value = dataItem.get(field);\r\n                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(value)) {\r\n                    if (dataItem.open) {\r\n                        this._updateDates(dataItem.open[field]);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Convers value to a relative position on axis.\r\n     *\r\n     * @param   value  Value\r\n     * @return         Relative position\r\n     */\r\n    valueToPosition(value) {\r\n        const dates = this._dates;\r\n        const startLocation = this.get(\"startLocation\", 0);\r\n        const endLocation = this.get(\"endLocation\", 1);\r\n        const len = dates.length - startLocation - (1 - endLocation);\r\n        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.getSortedIndex(dates, (x) => _core_util_Order__WEBPACK_IMPORTED_MODULE_2__.compare(x, value));\r\n        let index = result.index;\r\n        if (result.found) {\r\n            return (index - startLocation) / len;\r\n        }\r\n        else {\r\n            if (index > 0) {\r\n                index -= 1;\r\n            }\r\n            let itemValue = dates[index];\r\n            let d = 0;\r\n            if (itemValue > value) {\r\n                d = itemValue - value;\r\n            }\r\n            else {\r\n                d = value - itemValue;\r\n            }\r\n            return (index - startLocation) / len + d / this.baseDuration() / len;\r\n        }\r\n    }\r\n    /**\r\n     * Converts numeric value from axis scale to index.\r\n     *\r\n     * @param  value  Value\r\n     * @return        Index\r\n     */\r\n    valueToIndex(value) {\r\n        const dates = this._dates;\r\n        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.getSortedIndex(dates, (x) => _core_util_Order__WEBPACK_IMPORTED_MODULE_2__.compare(x, value));\r\n        let index = result.index;\r\n        if (result.found) {\r\n            return index;\r\n        }\r\n        else {\r\n            if (index > 0) {\r\n                index -= 1;\r\n            }\r\n            return index;\r\n        }\r\n    }\r\n    /**\r\n     * Converts a relative position to a corresponding numeric value from axis\r\n     * scale.\r\n     *\r\n     * @param   position  Relative position\r\n     * @return            Value\r\n     */\r\n    positionToValue(position) {\r\n        const startLocation = this.get(\"startLocation\", 0);\r\n        const endLocation = this.get(\"endLocation\", 1);\r\n        let len = Math.round(this._dates.length - startLocation - (1 - endLocation));\r\n        let index = position * len;\r\n        let findex = Math.floor(index);\r\n        if (findex < 0) {\r\n            findex = 0;\r\n        }\r\n        if (findex > len - 1) {\r\n            findex = len - 1;\r\n        }\r\n        return this._dates[findex] + (index - findex + startLocation) * this.baseDuration();\r\n    }\r\n    _fixZoomFactor() {\r\n        this.setPrivateRaw(\"maxZoomFactor\", this._dates.length - this.get(\"startLocation\", 0) - (1 - this.get(\"endLocation\", 1)));\r\n    }\r\n    /**\r\n     * Zooms the axis to specific `start` and `end` values.\r\n     *\r\n     * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n     *\r\n     * @param  start     Start value\r\n     * @param  end       End value\r\n     * @param  duration  Duration in milliseconds\r\n     */\r\n    zoomToValues(start, end, duration) {\r\n        const min = this.getPrivate(\"min\", 0);\r\n        const max = this.getPrivate(\"max\", 0);\r\n        start = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.fitToRange(start, min, max);\r\n        end = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.fitToRange(end, min, max);\r\n        this.zoom(this.valueToPosition(start), this.valueToPosition(end), duration);\r\n    }\r\n    _prepareAxisItems() {\r\n        let startTime = this.getPrivate(\"selectionMin\", 0);\r\n        let endTime = this.getPrivate(\"selectionMax\", 0);\r\n        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(startTime) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(endTime)) {\r\n            if (this._seriesValuesDirty) {\r\n                this._seriesValuesDirty = false;\r\n                this._updateAllDates();\r\n            }\r\n            const dates = this._dates;\r\n            const renderer = this.get(\"renderer\");\r\n            const len = dates.length;\r\n            let startIndex = this.valueToIndex(startTime);\r\n            if (startIndex > 0) {\r\n                startIndex--;\r\n            }\r\n            let endIndex = this.valueToIndex(endTime);\r\n            if (endIndex < len - 1) {\r\n                endIndex++;\r\n            }\r\n            let maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\r\n            let frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\r\n            frequency = Math.max(1, frequency);\r\n            startIndex = Math.floor(startIndex / frequency) * frequency;\r\n            this._frequency = frequency;\r\n            for (let j = 0, length = this.dataItems.length; j < length; j++) {\r\n                this.dataItems[j].hide();\r\n            }\r\n            let realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\r\n            // if all items are on axis\r\n            let gridInterval = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\r\n            const baseInterval = this.getPrivate(\"baseInterval\");\r\n            let intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.getIntervalDuration(gridInterval);\r\n            if (intervalDuration < this.baseDuration()) {\r\n                gridInterval = Object.assign({}, baseInterval);\r\n                intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.getIntervalDuration(gridInterval);\r\n            }\r\n            this._intervalDuration = intervalDuration;\r\n            const formats = this.get(\"dateFormats\");\r\n            let selectedItems = [];\r\n            let firstDate = new Date();\r\n            if (this._dates[0]) {\r\n                firstDate = new Date(this._dates[0]);\r\n            }\r\n            let startDate = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.round(new Date(this.getPrivate(\"min\", 0)), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, firstDate, this._root.timezone);\r\n            let value = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.add(startDate, gridInterval.timeUnit, -1, this._root.utc, this._root.timezone).getTime();\r\n            let selectionMax = this.getPrivate(\"selectionMax\");\r\n            let previousPosition = -Infinity;\r\n            let minDifference = (this.get(\"end\", 1) - this.get(\"start\", 0)) / maxCount;\r\n            while (value <= selectionMax) {\r\n                let index = this.valueToIndex(value);\r\n                let realValue = this._dates[index];\r\n                if (realValue < value) {\r\n                    for (let i = index, len = this._dates.length; i < len; i++) {\r\n                        let realValue = this._dates[i];\r\n                        if (realValue >= value) {\r\n                            index = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                let position = this.valueToPosition(realValue);\r\n                if (position - previousPosition >= minDifference * 0.95) {\r\n                    _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.move(selectedItems, index);\r\n                    previousPosition = position;\r\n                }\r\n                let previousValue = value;\r\n                value += _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.getDuration(gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));\r\n                value = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.round(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\r\n                if (value == previousValue) {\r\n                    break;\r\n                }\r\n            }\r\n            if (selectedItems.length > 0) {\r\n                let i = 0;\r\n                let previousValue = value - intervalDuration * 10;\r\n                const nextGridUnit = _core_util_Time__WEBPACK_IMPORTED_MODULE_5__.getNextUnit(gridInterval.timeUnit);\r\n                _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(selectedItems, (index) => {\r\n                    let dataItem;\r\n                    if (this.dataItems.length < i + 1) {\r\n                        dataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_6__.DataItem(this, undefined, {});\r\n                        this._dataItems.push(dataItem);\r\n                        this.processDataItem(dataItem);\r\n                    }\r\n                    else {\r\n                        dataItem = this.dataItems[i];\r\n                    }\r\n                    let value = dates[index];\r\n                    let date = new Date(value);\r\n                    let endValue = value;\r\n                    if (i < selectedItems.length - 1) {\r\n                        endValue = dates[selectedItems[i + 1]];\r\n                    }\r\n                    else {\r\n                        endValue += intervalDuration;\r\n                    }\r\n                    dataItem.setRaw(\"value\", value);\r\n                    dataItem.setRaw(\"endValue\", endValue);\r\n                    dataItem.setRaw(\"index\", i);\r\n                    if (index > startIndex - 100 && index < endIndex + 100) {\r\n                        let format = formats[gridInterval.timeUnit];\r\n                        format = formats[gridInterval.timeUnit];\r\n                        if (nextGridUnit && this.get(\"markUnitChange\") && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(previousValue)) {\r\n                            if (gridInterval.timeUnit != \"year\") {\r\n                                if (_core_util_Time__WEBPACK_IMPORTED_MODULE_5__.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\r\n                                    format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\r\n                                }\r\n                            }\r\n                        }\r\n                        this._createAssets(dataItem, []);\r\n                        const label = dataItem.get(\"label\");\r\n                        if (label) {\r\n                            label.set(\"text\", this._root.dateFormatter.format(date, format));\r\n                        }\r\n                        if (dataItem.isHidden()) {\r\n                            dataItem.show();\r\n                        }\r\n                        this._prepareDataItem(dataItem, gridInterval.count);\r\n                    }\r\n                    i++;\r\n                    previousValue = value;\r\n                });\r\n            }\r\n            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(this.series, (series) => {\r\n                if (series.inited) {\r\n                    series._markDirtyAxes();\r\n                }\r\n            });\r\n        }\r\n        this._updateGhost();\r\n    }\r\n}\r\nObject.defineProperty(GaplessDateAxis, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"GaplessDateAxis\"\r\n});\r\nObject.defineProperty(GaplessDateAxis, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: _DateAxis__WEBPACK_IMPORTED_MODULE_0__.DateAxis.classNames.concat([GaplessDateAxis.className])\r\n});\r\n//# sourceMappingURL=GaplessDateAxis.js.map\n\n//# sourceURL=webpack://cbdc-carbon-reporting-dashboard/./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/GaplessDateAxis.js?");

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Candlestick: () => (/* binding */ Candlestick)\n/* harmony export */ });\n/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/RoundedRectangle */ \"./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js\");\n\r\n/**\r\n * A candle element used in a [[CandlestickSeries]].\r\n */\r\nclass Candlestick extends _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__.RoundedRectangle {\r\n    _beforeChanged() {\r\n        super._beforeChanged();\r\n        if (this.isDirty(\"lowX0\") || this.isDirty(\"lowY0\") || this.isDirty(\"lowX1\") || this.isDirty(\"lowY1\") || this.isDirty(\"highX0\") || this.isDirty(\"highX1\") || this.isDirty(\"highY0\") || this.isDirty(\"highY1\")) {\r\n            this._clear = true;\r\n        }\r\n    }\r\n    _draw() {\r\n        super._draw();\r\n        const display = this._display;\r\n        display.moveTo(this.get(\"lowX0\", 0), this.get(\"lowY0\", 0));\r\n        display.lineTo(this.get(\"lowX1\", 0), this.get(\"lowY1\", 0));\r\n        display.moveTo(this.get(\"highX0\", 0), this.get(\"highY0\", 0));\r\n        display.lineTo(this.get(\"highX1\", 0), this.get(\"highY1\", 0));\r\n    }\r\n}\r\nObject.defineProperty(Candlestick, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"Candlestick\"\r\n});\r\nObject.defineProperty(Candlestick, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__.RoundedRectangle.classNames.concat([Candlestick.className])\r\n});\r\n//# sourceMappingURL=Candlestick.js.map\n\n//# sourceURL=webpack://cbdc-carbon-reporting-dashboard/./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js?");

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandlestickSeries: () => (/* binding */ CandlestickSeries)\n/* harmony export */ });\n/* harmony import */ var _ColumnSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnSeries */ \"./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js\");\n/* harmony import */ var _Candlestick__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Candlestick */ \"./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js\");\n/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Template */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js\");\n/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/List */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/List.js\");\n/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js\");\n/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Array */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Candlestick series.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/candlestick-series/} for more info\r\n * @important\r\n */\r\nclass CandlestickSeries extends _ColumnSeries__WEBPACK_IMPORTED_MODULE_0__.ColumnSeries {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * A list of candles in the series.\r\n         *\r\n         * `columns.template` can be used to configure candles.\r\n         *\r\n         * @default new ListTemplate<Candlestick>\r\n         */\r\n        Object.defineProperty(this, \"columns\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({\r\n                themeTags: [\"autocolor\"]\r\n            }), () => _Candlestick__WEBPACK_IMPORTED_MODULE_3__.Candlestick._new(this._root, {\r\n                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.columns.template.get(\"themeTags\", []), [\"candlestick\", \"series\", \"column\"])\r\n            }, [this.columns.template]))\r\n        });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    makeColumn(dataItem, listTemplate) {\r\n        const column = this.mainContainer.children.push(listTemplate.make());\r\n        column._setDataItem(dataItem);\r\n        listTemplate.push(column);\r\n        return column;\r\n    }\r\n    _updateGraphics(dataItem, previousDataItem) {\r\n        super._updateGraphics(dataItem, previousDataItem);\r\n        const xAxis = this.getRaw(\"xAxis\");\r\n        const yAxis = this.getRaw(\"yAxis\");\r\n        const baseAxis = this.getRaw(\"baseAxis\");\r\n        let vcy = this.get(\"vcy\", 1);\r\n        let vcx = this.get(\"vcx\", 1);\r\n        let lx0;\r\n        let lx1;\r\n        let ly0;\r\n        let ly1;\r\n        let hx0;\r\n        let hx1;\r\n        let hy0;\r\n        let hy1;\r\n        let locationX = this.get(\"locationX\", dataItem.get(\"locationX\", 0.5));\r\n        let locationY = this.get(\"locationY\", dataItem.get(\"locationY\", 0.5));\r\n        let openLocationX = this.get(\"openLocationX\", dataItem.get(\"openLocationX\", locationX));\r\n        let openLocationY = this.get(\"openLocationY\", dataItem.get(\"openLocationY\", locationY));\r\n        let orientation;\r\n        if (yAxis === baseAxis) {\r\n            let open = xAxis.getDataItemPositionX(dataItem, this._xOpenField, 1, vcx);\r\n            let close = xAxis.getDataItemPositionX(dataItem, this._xField, 1, vcx);\r\n            lx1 = xAxis.getDataItemPositionX(dataItem, this._xLowField, 1, vcx);\r\n            hx1 = xAxis.getDataItemPositionX(dataItem, this._xHighField, 1, vcx);\r\n            hx0 = Math.max(open, close);\r\n            lx0 = Math.min(open, close);\r\n            let startLocation = this._aLocationY0 + openLocationY - 0.5;\r\n            let endLocation = this._aLocationY1 + locationY - 0.5;\r\n            ly0 = yAxis.getDataItemPositionY(dataItem, this._yField, startLocation + (endLocation - startLocation) / 2, vcy);\r\n            ly1 = ly0;\r\n            hy0 = ly0;\r\n            hy1 = ly0;\r\n            orientation = \"horizontal\";\r\n        }\r\n        else {\r\n            let open = yAxis.getDataItemPositionY(dataItem, this._yOpenField, 1, vcy);\r\n            let close = yAxis.getDataItemPositionY(dataItem, this._yField, 1, vcy);\r\n            ly1 = yAxis.getDataItemPositionY(dataItem, this._yLowField, 1, vcy);\r\n            hy1 = yAxis.getDataItemPositionY(dataItem, this._yHighField, 1, vcy);\r\n            hy0 = Math.max(open, close);\r\n            ly0 = Math.min(open, close);\r\n            let startLocation = this._aLocationX0 + openLocationX - 0.5;\r\n            let endLocation = this._aLocationX1 + locationX - 0.5;\r\n            lx0 = xAxis.getDataItemPositionX(dataItem, this._xField, startLocation + (endLocation - startLocation) / 2, vcx);\r\n            lx1 = lx0;\r\n            hx0 = lx0;\r\n            hx1 = lx0;\r\n            orientation = \"vertical\";\r\n        }\r\n        this._updateCandleGraphics(dataItem, lx0, lx1, ly0, ly1, hx0, hx1, hy0, hy1, orientation);\r\n    }\r\n    _updateCandleGraphics(dataItem, lx0, lx1, ly0, ly1, hx0, hx1, hy0, hy1, orientation) {\r\n        let column = dataItem.get(\"graphics\");\r\n        if (column) {\r\n            let pl0 = this.getPoint(lx0, ly0);\r\n            let pl1 = this.getPoint(lx1, ly1);\r\n            let ph0 = this.getPoint(hx0, hy0);\r\n            let ph1 = this.getPoint(hx1, hy1);\r\n            let x = column.x();\r\n            let y = column.y();\r\n            column.set(\"lowX0\", pl0.x - x);\r\n            column.set(\"lowY0\", pl0.y - y);\r\n            column.set(\"lowX1\", pl1.x - x);\r\n            column.set(\"lowY1\", pl1.y - y);\r\n            column.set(\"highX0\", ph0.x - x);\r\n            column.set(\"highY0\", ph0.y - y);\r\n            column.set(\"highX1\", ph1.x - x);\r\n            column.set(\"highY1\", ph1.y - y);\r\n            column.set(\"orientation\", orientation);\r\n            let rangeGraphics = dataItem.get(\"rangeGraphics\");\r\n            if (rangeGraphics) {\r\n                _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.each(rangeGraphics, (column) => {\r\n                    column.set(\"lowX0\", pl0.x - x);\r\n                    column.set(\"lowY0\", pl0.y - y);\r\n                    column.set(\"lowX1\", pl1.x - x);\r\n                    column.set(\"lowY1\", pl1.y - y);\r\n                    column.set(\"highX0\", ph0.x - x);\r\n                    column.set(\"highY0\", ph0.y - y);\r\n                    column.set(\"highX1\", ph1.x - x);\r\n                    column.set(\"highY1\", ph1.y - y);\r\n                    column.set(\"orientation\", orientation);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    _processAxisRange(axisRange) {\r\n        super._processAxisRange(axisRange);\r\n        axisRange.columns = new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _Candlestick__WEBPACK_IMPORTED_MODULE_3__.Candlestick._new(this._root, {\r\n            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(axisRange.columns.template.get(\"themeTags\", []), [\"candlestick\", \"series\", \"column\"]),\r\n        }, [this.columns.template, axisRange.columns.template]));\r\n    }\r\n}\r\nObject.defineProperty(CandlestickSeries, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"CandlestickSeries\"\r\n});\r\nObject.defineProperty(CandlestickSeries, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: _ColumnSeries__WEBPACK_IMPORTED_MODULE_0__.ColumnSeries.classNames.concat([CandlestickSeries.className])\r\n});\r\n//# sourceMappingURL=CandlestickSeries.js.map\n\n//# sourceURL=webpack://cbdc-carbon-reporting-dashboard/./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js?");

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSeries: () => (/* binding */ ColumnSeries)\n/* harmony export */ });\n/* harmony import */ var _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseColumnSeries */ \"./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js\");\n/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Template */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js\");\n/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/List */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/List.js\");\n/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/render/RoundedRectangle */ \"./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js\");\n/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ \"./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js\");\n\r\n\r\n\r\n\r\n\r\nclass ColumnSeries extends _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__.BaseColumnSeries {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * A [[TemplateList]] of all columns in series.\r\n         *\r\n         * `columns.template` can be used to set default settings for all columns,\r\n         * or to change on existing ones.\r\n         */\r\n        Object.defineProperty(this, \"columns\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__.RoundedRectangle._new(this._root, {\r\n                position: \"absolute\",\r\n                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.columns.template.get(\"themeTags\", []), [\"series\", \"column\"])\r\n            }, [this.columns.template]))\r\n        });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    makeColumn(dataItem, listTemplate) {\r\n        const column = this.mainContainer.children.push(listTemplate.make());\r\n        column._setDataItem(dataItem);\r\n        listTemplate.push(column);\r\n        return column;\r\n    }\r\n    _processAxisRange(axisRange) {\r\n        super._processAxisRange(axisRange);\r\n        axisRange.columns = new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__.RoundedRectangle._new(this._root, {\r\n            position: \"absolute\",\r\n            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(axisRange.columns.template.get(\"themeTags\", []), [\"series\", \"column\"]),\r\n        }, [this.columns.template, axisRange.columns.template]));\r\n    }\r\n}\r\nObject.defineProperty(ColumnSeries, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"ColumnSeries\"\r\n});\r\nObject.defineProperty(ColumnSeries, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__.BaseColumnSeries.classNames.concat([ColumnSeries.className])\r\n});\r\n//# sourceMappingURL=ColumnSeries.js.map\n\n//# sourceURL=webpack://cbdc-carbon-reporting-dashboard/./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js?");

/***/ })

}]);